package libdwarf;
import com.ochafik.lang.jnaerator.runtime.Structure;
import java.util.Arrays;
import java.util.List;
/**
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class Dwarf_Regtable_Entry_s extends Structure<Dwarf_Regtable_Entry_s, Dwarf_Regtable_Entry_s.ByValue, Dwarf_Regtable_Entry_s.ByReference > {
	/**
	 * For each index i (naming a hardware register with dwarf number<br>
	 * i) the following is true and defines the value of that register:<br>
	 * If dw_regnum is Register DW_FRAME_UNDEFINED_VAL<br>
	 * it is not DWARF register number but<br>
	 * a place holder indicating the register has no defined value.<br>
	 * If dw_regnum is Register DW_FRAME_SAME_VAL<br>
	 * it  is not DWARF register number but<br>
	 * a place holder indicating the register has the same<br>
	 * value in the previous frame.<br>
	 * DW_FRAME_UNDEFINED_VAL, DW_FRAME_SAME_VAL are<br>
	 * only present at libdwarf runtime. Never on disk.<br>
	 * DW_FRAME_* Values present on disk are in dwarf.h<br>
	 * Otherwise: the register number is a DWARF register number<br>
	 * (see ABI documents for how this translates to hardware/<br>
	 * software register numbers in the machine hardware)<br>
	 * and the following applies:<br>
	 * if dw_value_type == DW_EXPR_OFFSET (the only case for dwarf2):<br>
	 * If dw_offset_relevant is non-zero, then<br>
	 * the value is stored at at the address CFA+N where<br>
	 * N is a signed offset.<br>
	 * Rule: Offset(N)<br>
	 * If dw_offset_relevant is zero, then the value of the register<br>
	 * is the value of (DWARF) register number dw_regnum.<br>
	 * Rule: register(F)<br>
	 * Other values of dw_value_type are an error.<br>
	 * C type : Dwarf_Small
	 */
	public byte dw_offset_relevant;
	/**
	 * For DWARF2, always 0<br>
	 * C type : Dwarf_Small
	 */
	public byte dw_value_type;
	/** C type : Dwarf_Half */
	public short dw_regnum;
	/**
	 * The data type here should  the larger of Dwarf_Addr<br>
	 * and Dwarf_Unsigned and Dwarf_Signed.<br>
	 * C type : Dwarf_Addr
	 */
	public long dw_offset;
	public Dwarf_Regtable_Entry_s() {
		super();
	}
	protected List<? > getFieldOrder() {
		return Arrays.asList("dw_offset_relevant", "dw_value_type", "dw_regnum", "dw_offset");
	}
	/**
	 * @param dw_offset_relevant For each index i (naming a hardware register with dwarf number<br>
	 * i) the following is true and defines the value of that register:<br>
	 * If dw_regnum is Register DW_FRAME_UNDEFINED_VAL<br>
	 * it is not DWARF register number but<br>
	 * a place holder indicating the register has no defined value.<br>
	 * If dw_regnum is Register DW_FRAME_SAME_VAL<br>
	 * it  is not DWARF register number but<br>
	 * a place holder indicating the register has the same<br>
	 * value in the previous frame.<br>
	 * DW_FRAME_UNDEFINED_VAL, DW_FRAME_SAME_VAL are<br>
	 * only present at libdwarf runtime. Never on disk.<br>
	 * DW_FRAME_* Values present on disk are in dwarf.h<br>
	 * Otherwise: the register number is a DWARF register number<br>
	 * (see ABI documents for how this translates to hardware/<br>
	 * software register numbers in the machine hardware)<br>
	 * and the following applies:<br>
	 * if dw_value_type == DW_EXPR_OFFSET (the only case for dwarf2):<br>
	 * If dw_offset_relevant is non-zero, then<br>
	 * the value is stored at at the address CFA+N where<br>
	 * N is a signed offset.<br>
	 * Rule: Offset(N)<br>
	 * If dw_offset_relevant is zero, then the value of the register<br>
	 * is the value of (DWARF) register number dw_regnum.<br>
	 * Rule: register(F)<br>
	 * Other values of dw_value_type are an error.<br>
	 * C type : Dwarf_Small<br>
	 * @param dw_value_type For DWARF2, always 0<br>
	 * C type : Dwarf_Small<br>
	 * @param dw_regnum C type : Dwarf_Half<br>
	 * @param dw_offset The data type here should  the larger of Dwarf_Addr<br>
	 * and Dwarf_Unsigned and Dwarf_Signed.<br>
	 * C type : Dwarf_Addr
	 */
	public Dwarf_Regtable_Entry_s(byte dw_offset_relevant, byte dw_value_type, short dw_regnum, long dw_offset) {
		super();
		this.dw_offset_relevant = dw_offset_relevant;
		this.dw_value_type = dw_value_type;
		this.dw_regnum = dw_regnum;
		this.dw_offset = dw_offset;
	}
	protected ByReference newByReference() { return new ByReference(); }
	protected ByValue newByValue() { return new ByValue(); }
	protected Dwarf_Regtable_Entry_s newInstance() { return new Dwarf_Regtable_Entry_s(); }
	public static Dwarf_Regtable_Entry_s[] newArray(int arrayLength) {
		return Structure.newArray(Dwarf_Regtable_Entry_s.class, arrayLength);
	}
	public static class ByReference extends Dwarf_Regtable_Entry_s implements Structure.ByReference {
		
	};
	public static class ByValue extends Dwarf_Regtable_Entry_s implements Structure.ByValue {
		
	};
}
